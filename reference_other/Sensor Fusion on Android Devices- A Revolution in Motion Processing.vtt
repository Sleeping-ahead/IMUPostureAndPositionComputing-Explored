WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.000 --> 00:00:25.109
&gt;&gt;

00:00:25.109 --> 00:00:33.570
大家好。 谢谢你出来。 我
今天的嘉宾是大卫萨克斯。 他开始

00:00:33.570 --> 00:00:39.690
在麻省理工学院媒体实验室开发运动传感应用程序
。 现在他在 InvenSense 从事高级应用程序

00:00:39.690 --> 00:00:45.290
开发，在那里他
用罗盘、

00:00:45.290 --> 00:00:53.370
加速度计和陀螺仪做了很多有趣的事情，包括将
它们构建到 Android 设备中。 请和我一起

00:00:53.370 --> 00:01:04.549
欢迎 David Sachs。
&gt;&gt; SACHS：所以本次演讲的目的是

00:01:04.549 --> 00:01:12.000
了解消费电子产品中的传感器。
这包括加速度计、陀螺仪

00:01:12.000 --> 00:01:18.399
和罗盘。 这有点像动物园，里面有所有
这些不同的传感器。 有

00:01:18.399 --> 00:01:22.450
一个大问题，人们并不真正知道如何
使用它们。 他们不一定知道

00:01:22.450 --> 00:01:25.950
传感器的作用或它们的
优缺点。 他们不知道如何将

00:01:25.950 --> 00:01:31.030
数据放在一起。 还有很多
关于不同设备中实际内容的错误信息，

00:01:31.030 --> 00:01:38.720
这会造成很多混乱。
因此，我想向

00:01:38.720 --> 00:01:43.930
您将在新闻稿中看到的一些不存在的传感器表示敬意。
即使它们不存在，人们也会在论坛上写下

00:01:43.930 --> 00:01:48.990
各种关于它们的有趣内容
。 根据 Sprint 的说法，其中包括三星 Epic 显然拥有的六轴加速度计

00:01:48.990 --> 00:01:56.729
 
。 六轴陀螺仪。 非常

00:01:56.729 --> 00:02:05.210
神秘的陀螺加速度计和
陀螺罗盘。 陀螺仪，我不得不说，

00:02:05.210 --> 00:02:10.830
确实存在。 有
陀螺罗盘之类的东西。 它目前未在任何

00:02:10.830 --> 00:02:20.069
Android 设备中发售。 它看起来有点像
那样。 也许有一天。 因此，本次演讲将从

00:02:20.069 --> 00:02:25.780
介绍一些应用程序示例开始。
我们将向您展示一些演示，然后我们将进入

00:02:25.780 --> 00:02:30.560
更科学的方面。 我们将
讨论传感器本身； 加速度计、

00:02:30.560 --> 00:02:34.970
指南针和陀螺仪。 然后我们将
讨论传感器融合。 你怎么把这些东西放在

00:02:34.970 --> 00:02:42.810
一起？ 系统集成，我的
意思是，我们是怎么做到的？ 所以这是

00:02:42.810 --> 00:02:48.790
轴一的修改。 它有加速度计、指南针
和陀螺仪。 它做传感器融合，

00:02:48.790 --> 00:02:53.370
我们在它上面写了一堆应用程序
。 为了将额外的硬件放入

00:02:53.370 --> 00:02:57.459
其中，我们必须先拆掉一些东西，所以
我会让你们猜猜

00:02:57.459 --> 00:03:03.930
我们拆掉的是什么，您会
在谈话进行到一半时发现。 然后，当然，

00:03:03.930 --> 00:03:07.900
你知道，真的没有人关心所有
这些东西。 他们只想使用传感器融合。

00:03:07.900 --> 00:03:14.380
大多数人只想编写
使用运动的应用程序，因此，您知道，希望这项

00:03:14.380 --> 00:03:18.330
技术可以让应用程序开发人员的生活更轻松
。 因此，他们不必担心

00:03:18.330 --> 00:03:22.090
什么是加速度计、什么是陀螺仪、
什么是指南针，以及如何将所有这些

00:03:22.090 --> 00:03:26.080
数据放在一起？ 他们只是想知道如何
使用由此产生的信息。

00:03:26.080 --> 00:03:33.209
那么让我们从一些应用
示例开始吧。 赌博。 游戏真的很有趣。 这场

00:03:33.209 --> 00:03:38.459
派对从任天堂开始。 他们做了体
感游戏。 现在大家都在做。

00:03:38.459 --> 00:03:44.210
因此，我将直接进入并向
您展示一些体感游戏演示。

00:03:44.210 --> 00:03:50.709
好的。 所以，这不是游戏。 它只是一把
剑，但你可以看到它做我做的事。 这

00:03:50.709 --> 00:03:57.209
很酷。 所以这使用了陀螺仪、加速度计
和罗盘来测量各种方向。

00:03:57.209 --> 00:04:03.700
你可以看到它非常稳定，
当我移动时它会快速移动，当我停止时它会停止。

00:04:03.700 --> 00:04:08.340
LAN 在该系统上的性能非常低，但我
不确定这是否会在

00:04:08.340 --> 00:04:20.539
VC 系统上实现。 但这不是游戏。 我答应过
你一场比赛。 所以这是游戏。 我正飞过

00:04:20.539 --> 00:04:27.129
一条隧道。 这是我的隧道。 我可以
向左、向右、向上、向下。 我可以侧身

00:04:27.129 --> 00:04:32.259
如果我愿意，我可以倒飞。 我必须
飞过这些门。

00:04:32.259 --> 00:04:38.669
在对着麦克风讲话时很难做到这一点。 是的。
那是一个体感游戏。 很有趣。

00:04:38.669 --> 00:04:43.199
所以我们将在谈话结束时来到这个游戏，
我会告诉你我们是如何做到的。

00:04:43.199 --> 00:04:51.259
继续。 所以这里有一些更多的应用程序。 我们有
虚拟现实和增强现实。

00:04:51.259 --> 00:04:54.659
左边是虚拟现实，
右边是增强现实，

00:04:54.659 --> 00:05:00.780
中间是街景。 我不知道。
这有点像经过增强的真实虚拟现实

00:05:00.780 --> 00:05:07.610
。 我不知道，但所有
这些都使用运动感应。 所以我会

00:05:07.610 --> 00:05:12.460
在我们的手机上给你看这个。 这会有点难看，
但我也有一个视频可以给你看

00:05:12.460 --> 00:05:20.669
。 这就是我们的虚拟现实系统。
我可以往下看 我可以抬头看看 我可以

00:05:20.669 --> 00:05:28.550
期待。 侧身，很酷？ 因此，
其中的运动感应部分基本上是

00:05:28.550 --> 00:05:32.990
一行代码。 获得传感器融合的输出后
，您只需绘制一些 3D 内容

00:05:32.990 --> 00:05:37.210
并输入一行代码即可。 因此，对于那些
看不到的人，这是

00:05:37.210 --> 00:05:43.020
基本上完全相同的视频。 这是
在 G1 上运行的旧系统，但实际上是

00:05:43.020 --> 00:05:55.770
相同的应用程序。 所以，你可以看到。
所以在这里它关闭了传感器融合，所以

00:05:55.770 --> 00:05:59.770
现在它只是加速度计和指南针，
它仍然可以工作。 事实上，你已经可以做所有

00:05:59.770 --> 00:06:04.309
这些事情了，对吧？ 它只是
有点慢。 这是

00:06:04.309 --> 00:06:09.189
所有传感器融合所增加的主要内容。 它只是
升级了运动感应功能。

00:06:09.189 --> 00:06:18.590
好的，所以鼠标。 这是一个
带有陀螺仪和加速度计的鼠标示例

00:06:18.590 --> 00:06:26.199
。 它进行一些传感器融合并控制
光标。

00:06:26.199 --> 00:06:33.059
这是它的演示。 这是一只陀螺鼠，
很简单，对吧？

00:06:33.059 --> 00:06:36.259
一旦完成所有传感器融合，
基本上就很容易做到。 同样，只需几行

00:06:36.259 --> 00:06:40.729
代码即可完成此类操作。 所以
当我停下来它就停止了； 当我移动时移动； 左，右，

00:06:40.729 --> 00:06:50.360
上，下。
用户界面，好的。 好吧，用户界面有点

00:06:50.360 --> 00:06:55.809
像动物园。
您可以做各种各样的事情，并将其称为用户界面。

00:06:55.809 --> 00:07:00.649
我要放一段小视频。 我们也
有运行所有这些东西的手机。

00:07:00.649 --> 00:07:05.809
如果你愿意，你们可以稍后玩它。
这就是我们所做的。 我们使用动作放大，

00:07:05.809 --> 00:07:11.979
然后您也可以使用动作平移。
你可以只用一只手做很多事情，

00:07:11.979 --> 00:07:16.159
这很好。 您
不必弄脏屏幕，而且您知道

00:07:16.159 --> 00:07:19.459
 
用一只手捏合缩放有点棘手。 这有点容易。

00:07:19.459 --> 00:07:27.639
这里有一些更复杂的东西，所以有
一些手势。 您可以在空中画一个字母

00:07:27.639 --> 00:07:34.699
并启动一个应用程序。 您
还可以训练签名。 所以在这里，他正在

00:07:34.699 --> 00:07:39.240
训练字母 M，因为他的名字是
Mike。 一旦他训练了他的签名，那么

00:07:39.240 --> 00:07:44.559
，你知道，他可以去一个授权
应用程序，然后

00:07:44.559 --> 00:07:49.710
他可以
在空中画出他的字母 M，而不是输入一些会弄脏屏幕的东西，然后它就会解锁。

00:07:49.710 --> 00:07:55.770
如果你绘制一些其他图案，它
不起作用。 因此，

00:07:55.770 --> 00:07:59.559
一旦将所有传感器
数据放在一起，您就不必再

00:07:59.559 --> 00:08:05.110
担心什么是加速度计，这些都是很容易做到的事情的例子？
什么是指南针？ 什么是陀螺仪？ 图像

00:08:05.110 --> 00:08:09.209
稳定，我们今天在这里没有很好的演示，
但这是人们

00:08:09.209 --> 00:08:15.199
几十年来一直在使用这些传感器做的事情。
当然还有导航，这就

00:08:15.199 --> 00:08:19.520
另当别论了。 这东西挺难的。 我们会
略微提及，但您知道，我

00:08:19.520 --> 00:08:26.999
不会深入探讨导航
算法的工作原理。 而且，当然，所有这些

00:08:26.999 --> 00:08:31.770
东西都在手机上运行，​​这就是为什么这
对 Android 来说真的很有趣。 一旦传感器从

00:08:31.770 --> 00:08:35.570
系统中抽象出来，你就
得到了传感器融合数据的结果，

00:08:35.570 --> 00:08:40.370
那么你就可以编写 upset 来利用
所有这些东西。 那么让我们直接进入

00:08:40.370 --> 00:08:46.660
关于传感器的科学部分。 加速度计，
最容易可视化为弹簧上的质量。

00:08:46.660 --> 00:08:50.420
它们非常简单。 当
你摇动它们时，它们会摇晃，它们几乎可以捕捉到每

00:08:50.420 --> 00:08:55.089
一种运动，这是个好消息。
坏消息是它们几乎可以捕捉到每

00:08:55.089 --> 00:08:58.889
一种运动。 通常，您不知道
自己实际看到的是什么。 所以

00:08:58.889 --> 00:09:05.620
这里有一些例子。 质量会在
重力作用下下垂，对吗？ 所以，这很直观。

00:09:05.620 --> 00:09:09.380
当然，在真正的加速度计中，您
没有这些卷曲的弹簧。 你的梁通常是

00:09:09.380 --> 00:09:15.740
弯曲的。 如果你放下它，它实际上测量
为零。 这有点奇怪。 你第一次

00:09:15.740 --> 00:09:20.410
玩加速度计，那是
自由落体，原因是重力

00:09:20.410 --> 00:09:24.580
同时拉动加速度计中间的质量和
框架。 因此，

00:09:24.580 --> 00:09:29.650
质量和框架之间没有相对运动
。 那么你是如何测量重力的呢？

00:09:29.650 --> 00:09:34.090
好吧，有这个额外的力量支撑
着结构。 所以当你有额外的

00:09:34.090 --> 00:09:38.490
力支撑结构时，质量
会在重力作用下下垂。 所以，

00:09:38.490 --> 00:09:42.800
如果你稍微玩过加速度计，这会给出令人惊讶的结果
。 如果您将

00:09:42.800 --> 00:09:48.230
加速度计轴指向上方，它实际上会
测量到 1G。 所以，你可能认为

00:09:48.230 --> 00:09:52.540
它会测量一个负数，因为重力
将它拉下来，但这不是

00:09:52.540 --> 00:09:57.910
它的工作方式。 它实际上是在测量
你举起加速度计的力。 所以

00:09:57.910 --> 00:10:03.300
刚暴露在重力下的加速度计实际上输出为零。
当然，它也测量横向运动；

00:10:03.300 --> 00:10:08.250
你左右摇动它，加速
它，质量会受到反作用力

00:10:08.250 --> 00:10:13.750
，通常你会得到这样的东西。
所以这通常就是您要查看的内容。

00:10:13.750 --> 00:10:18.430
这只是一团糟，你不知道
你在看什么。 所以，这是

00:10:18.430 --> 00:10:24.250
一个加速度计。 这是一个特写镜头。 就像
我说的那样，它有弯曲的横梁，而不是卷曲的

00:10:24.250 --> 00:10:30.149
弹簧。 这是使用 MEMS 技术。 非常
有趣，你可以将机械结构蚀刻

00:10:30.149 --> 00:10:36.959
到硅中，这样它就非常便宜，
而且你可以很容易地将逻辑放在它旁边。

00:10:36.959 --> 00:10:41.930
圆规，所以圆规不再像
那样了。 这就是你的想象。  Compass

00:10:41.930 --> 00:10:47.140
是一种磁场传感器，它会拾取所有
可能的磁场，包括

00:10:47.140 --> 00:10:51.720
旁边的振动电机。 如果这
不是电话，它包含一些来自

00:10:51.720 --> 00:10:56.560
蓝牙芯片的东西。 它包括扬声器、
麦克风以及电路板上任何被

00:10:56.560 --> 00:11:00.829
磁化的东西，
实际上有点像火车残骸。 我总是很惊讶

00:11:00.829 --> 00:11:07.990
这项在手机上的工作，但
考虑到嘈杂的环境，它实际上工作得很好。

00:11:07.990 --> 00:11:13.079
为什么需要三轴罗盘？ 我
经常收到这个问题。 好吧，如果你像

00:11:13.079 --> 00:11:18.970
这样握住你的指南针并且我的 X 轴和 Y 轴
是平的，那么我真的只需要 X 轴和

00:11:18.970 --> 00:11:24.920
Y 轴来测量我的航向。 但是如果我
这样拿着我的指南针，现在我的 X 轴和 Z 轴

00:11:24.920 --> 00:11:30.649
是平的，我需要一个 X 轴和一个 Z 轴来测量
我的航向。 因此，如果您不想告诉

00:11:30.649 --> 00:11:34.990
用户如何握住指南针，而是希望
他们随心所欲地握住它，那么您

00:11:34.990 --> 00:11:40.290
需要一个 3 轴指南针，还需要一个
加速度计。 因此，如果

00:11:40.290 --> 00:11:46.889
没有加速度计来告诉
您如何握住设备，您就无法在任何方向进行指南针。 磁场

00:11:46.889 --> 00:11:51.079
有点奇怪。 地球的磁场
并不完全指向北方，因此如果您有地磁北极，您需要

00:11:51.079 --> 00:11:58.340
知道您的 GPS 位置才能知道北方在哪里
。

00:11:58.340 --> 00:12:02.699
还有一种叫做磁倾角的东西。
磁场实际上不是水平的，

00:12:02.699 --> 00:12:08.250
它介于水平和垂直之间。
在这里，它实际上比水平更垂直。

00:12:08.250 --> 00:12:13.759
就像，与水平面呈 60 度角。 但是
有足够的水平组件来

00:12:13.759 --> 00:12:17.870
解析您的航向。 当然，当你
到达北极或南极时，你就

00:12:17.870 --> 00:12:25.100
完蛋了。 那么指南针是如何工作的呢？ 嗯，这
就是

00:12:25.100 --> 00:12:29.860
在消费电子产品中占据最大市场份额的指南针的工作原理。
没有纺纱针； 实际上，

00:12:29.860 --> 00:12:35.259
电线中只有电流，如果存在磁场，电线中的电流会因霍尔
效应而偏转，

00:12:35.259 --> 00:12:41.389
因此您实际上可以
仅使用纯硅电子器件来制造指南针。

00:12:41.389 --> 00:12:46.920
你真的不需要铁磁材料
。 这是 3 轴罗盘的特写镜头

00:12:46.920 --> 00:12:52.680
。 它有一些霍尔传感器和一些
逻辑。 那是一个指南针。 所以现在，我们开始使用

00:12:52.680 --> 00:12:59.129
陀螺仪。 所以陀螺仪是新来者。
陀螺仪感应角速度。 所以，这是

00:12:59.129 --> 00:13:03.850
非常不同的。 他们感觉不到
磁北或重力等外部参考。

00:13:03.850 --> 00:13:09.340
陀螺仪测量自己的旋转。 那
它是如何工作的呢？ 他们使用一种叫做

00:13:09.340 --> 00:13:14.290
科里奥利效应的东西。 因此，
当质量在移动

00:13:14.290 --> 00:13:20.079
并且参考系在旋转时，就会发生科里奥利效应。 所以
当这种情况发生时，你会在质量上产生一个虚拟的力

00:13:20.079 --> 00:13:26.360
，你可以了解你的
参考系是如何旋转的。 所以地球在

00:13:26.360 --> 00:13:32.839
自转。 所以地球的自转
对天气系统等事物有一些影响，

00:13:32.839 --> 00:13:37.810
天气系统在北半球
或南半球的自转方式取决于科里奥利

00:13:37.810 --> 00:13:42.140
效应。 如果有人告诉你，由于科里奥利效应，马桶
在北半球以一种方式旋转，而

00:13:42.140 --> 00:13:45.990
在南半球以另一种方式旋转，
那实际上是不

00:13:45.990 --> 00:13:52.670
正确的，除非你的马桶有几英里长
或类似的东西或完美抛光

00:13:52.670 --> 00:13:58.801
。 好的，那么您实际上是如何
获得科里奥利效应的呢？ 好吧，我说你

00:13:58.801 --> 00:14:03.029
必须移动一个质量，所以你也可以
非常非常快地来回移动那个质量。

00:14:03.029 --> 00:14:08.040
所以，这就是陀螺仪的作用。 它实际上在
振荡。  MEMS 陀螺仪中没有任何东西在旋转

00:14:08.040 --> 00:14:13.800
。 有了振荡，你可以通过观察发生的其他事情
从质量振荡中获得科里奥利效应

00:14:13.800 --> 00:14:19.400
 
。 所以质量振荡，

00:14:19.400 --> 00:14:25.970
提供扭矩，然后您可以查看
这些电容式传感 com 拾取

00:14:25.970 --> 00:14:31.040
该信号。 所以这是一个慢动作，
当然。 通常这些东西会以

00:14:31.040 --> 00:14:38.259
非常高的频率振荡，可能在 25 到 30 千赫兹之间。
所以你放置的实际振荡频率

00:14:38.259 --> 00:14:41.930
取决于
你试图避免的系统中的其他内容。 因此，如果您试图

00:14:41.930 --> 00:14:47.100
避免音频频率，或者如果
系统中有另一个电机以某个频率运行，

00:14:47.100 --> 00:14:52.930
您可能需要注意将
陀螺仪置于什么频率。 这是

00:14:52.930 --> 00:15:00.760
一个 3 轴陀螺仪的特写镜头。 所以你可以
在那个剖视图中看到这些机械结构。 这些是

00:15:00.760 --> 00:15:06.350
振动、摆动、感知和
东西的东西。 然后下面是

00:15:06.350 --> 00:15:11.660
具有所有逻辑的硅。 所以下面更大的芯片
进行所有的信号调节

00:15:11.660 --> 00:15:15.920
，实际上进行传感器融合。 所以这个
芯片有一个 3 轴陀螺仪，实际上可以进行

00:15:15.920 --> 00:15:22.970
传感器融合。 它从其他传感器获取输入。
因此，这将我们带到了传感器融合。 那么如何

00:15:22.970 --> 00:15:28.059
将所有这些数据放在一起呢？ 因此，让我们
从将加速度计和陀螺仪数据放在

00:15:28.059 --> 00:15:34.110
一起开始。 这是加速度计
用作倾斜传感器的示例。 所以，它基本上可以

00:15:34.110 --> 00:15:37.410
工作，但有点吵。 所以
每个人都做什么，他们过滤它。 所以这是一个低

00:15:37.410 --> 00:15:41.750
通滤波器。 它可以工作，但会产生延迟，这就是
倾斜游戏的加速度计

00:15:41.750 --> 00:15:46.600
总是有点慢的原因，因为要通过
所有这些噪音，您必须添加一个低通

00:15:46.600 --> 00:15:53.389
滤波器。 是的。 所以这是陀螺仪数据。 所以
陀螺仪数据看起来好多了。 真的很顺利。

00:15:53.389 --> 00:15:57.540
它没有那个奇怪的尖峰。 但是，
当然，陀螺仪数据也不完美，对吧？

00:15:57.540 --> 00:16:00.699
因为陀螺仪数据首先，它
实际上并没有测量重力，对吧？

00:16:00.699 --> 00:16:05.180
关键是要弄清楚你相
对于重力的倾斜度。 陀螺仪不能测量，

00:16:05.180 --> 00:16:11.100
加速度计可以。 所以，你知道，我们可以把
这些数据放在一起，我们从陀螺仪得到很好的动态

00:16:11.100 --> 00:16:15.350
响应，我们
从加速度计得到重力测量，

00:16:15.350 --> 00:16:29.499
然后我们就有了很好的东西。 所以
我会给你一个小演示，说明它是如何工作的。

00:16:29.499 --> 00:16:33.579
好的。 所以这只是
一大堆数据的一个小示波器截图。 因此，如果您

00:16:33.579 --> 00:16:42.019
查看 Y 加速度计图表，它位于
中间，右侧，您的右侧。 同样，

00:16:42.019 --> 00:16:46.870
如果我将 Y 轴指向上方，它会测量 1G，
当我将它指向下方时，它会变为负 1G，所以

00:16:46.870 --> 00:16:53.880
它测量的是倾斜，这就是 Y 加速度计。
它看起来有点嘈杂，那是我的手抖动

00:16:53.880 --> 00:16:57.519
实际上被放大了一点，因为
它增加了

00:16:57.519 --> 00:17:03.230
我手抖动的线性加速度。 如果我快速移动，你会
看到这些奇怪的尖峰，看到了吗？ 它应该

00:17:03.230 --> 00:17:10.339
得到一个方波，但我却得到了这些
奇怪的尖峰。 那么，现在让我们看看

00:17:10.339 --> 00:17:15.339
Z 陀螺仪数据。 所以 Z 陀螺仪就是
我现在正在旋转的轴，你会

00:17:15.339 --> 00:17:20.090
在 Z 陀螺仪上得到这个很好的大角速度信号
。 但每当我停下来时，它就会

00:17:20.090 --> 00:17:25.189
归零。 陀螺仪实际上并不测量
重力，它们测量旋转。 所以，无论

00:17:25.189 --> 00:17:37.309
我在哪里停下来，它都是零。 所以我需要以某种方式将这些数据放在
一起。

00:17:37.309 --> 00:17:41.871
所以，在左边我们有一个我们称之为重力的信号。
所以这是

00:17:41.871 --> 00:17:47.320
您在应用程序中可能需要的传感器融合输出之一。 如果
将 Y 重力与 Y 加速度计进行比较，

00:17:47.320 --> 00:17:52.250
您会发现它们看起来非常相似，对吧？
Y 重力更平滑，因为那个

00:17:52.250 --> 00:17:57.490
奇怪的抖动消失了。 如果我快速移动，
尖峰出现在加速度计

00:17:57.490 --> 00:18:02.390
数据中，但不出现在重力信号中。 所以
重力信号有点奇怪。 它实际上

00:18:02.390 --> 00:18:09.840
主要是陀螺仪数据，但加速度计
用于校正漂移。 所以这个重力数据

00:18:09.840 --> 00:18:13.340
可能是您在
编写基于加速度计的游戏时希望拥有的数据。

00:18:13.340 --> 00:18:24.230
它是——它是——你真正想要的是
传感器融合的输出，而不仅仅是一个传感器。

00:18:24.230 --> 00:18:29.050
总而言之，您所做的就是使用
陀螺仪，从中获取方向，

00:18:29.050 --> 00:18:34.870
然后使用加速度计注入校正
项，以保持相

00:18:34.870 --> 00:18:41.169
对于重力的方向正确并消除
漂移。 那么我们是如何

00:18:41.169 --> 00:18:46.360
从陀螺仪获得方向信号的呢？ 所以，你
必须做一些叫做整合的事情，对吧？

00:18:46.360 --> 00:18:51.420
所以，陀螺仪输出角速度，
你真正要的是角度。 所以你做单一

00:18:51.420 --> 00:18:57.830
集成。 集成有点奇怪。
蓝色的东西只是我产生的噪音，

00:18:57.830 --> 00:19:02.140
红色的东西是积分，你
可以看到它有非常不同的属性。

00:19:02.140 --> 00:19:08.890
所以它看起来不那么嘈杂但更漂移。 因此，
从直觉上讲，积分将噪声转化为

00:19:08.890 --> 00:19:13.880
漂移，这实际上是
陀螺仪信号如此干净的原因之一，因为

00:19:13.880 --> 00:19:19.230
它是积分的，这就是它背后的数学原理
。 如果对余弦积分，您会得到一个符号，

00:19:19.230 --> 00:19:24.830
但您也会得到前面出现的这个 1/f
。 这意味着，如果您

00:19:24.830 --> 00:19:30.190
的陀螺仪数据因噪声而抖动 100 赫兹，当您积分时，
它会下降 100 倍，因此您会消除

00:19:30.190 --> 00:19:35.140
噪声。 但另一方面，如果积分时
陀螺仪上有非常低频的噪声

00:19:35.140 --> 00:19:39.441
，它会被放大。 所以
你已经 - 你摆脱了你的噪音并

00:19:39.441 --> 00:19:47.450
增加了漂移。 所以整合是一种混合的
祝福。 所以，为了做好这件事，你

00:19:47.450 --> 00:19:53.500
必须快点做。 所以这是一个非常简化的
方程式，你对角速度进行积分，

00:19:53.500 --> 00:19:58.179
所以你将它乘以时间并累加
得到你的角度。 现在，

00:19:58.179 --> 00:20:02.960
为了做好这件事，时间必须非常
准确。 因此，您将陀螺仪

00:20:02.960 --> 00:20:08.390
数据乘以时间，这意味着，如果您的时间偏差
5%，则与陀螺仪数据

00:20:08.390 --> 00:20:13.340
偏差 5% 一样糟糕。 这是相同的影响，你
也希望你的时间间隔非常

00:20:13.340 --> 00:20:19.630
小。 所以我们所做的是在硬件中进行，
这样您就可以以非常快的速度进行。 基本上，

00:20:19.630 --> 00:20:24.141
你有你的传感器，然后你有一个单独的
运动处理器，然后你有一个应用程序

00:20:24.141 --> 00:20:28.870
处理器，
在我们的例子中，传感器和运动处理器都在一个芯片上，一块

00:20:28.870 --> 00:20:36.690
硅片上。 所以这种抽象出很多
这种高速率集成的东西。 那么，让我们

00:20:36.690 --> 00:20:41.649
继续吧。 所以，现在我们要合并罗盘
和陀螺仪数据。 这基本上是同一个

00:20:41.649 --> 00:20:47.070
故事。 指南针数据为您提供了您
想要的答案，即您的航向，但它很嘈杂——它很

00:20:47.070 --> 00:20:54.299
嘈杂有两个原因。 原因之一是
它接收到真实的噪音、真实的信号。 所以

00:20:54.299 --> 00:20:58.220
我们生活在一个磁性
非常嘈杂的环境中。 所以，这个圆规，他们

00:20:58.220 --> 00:21:02.751
捡起所有有磁性的东西。 另一个原因
是它没有集成，所以它

00:21:02.751 --> 00:21:10.280
没有降低频率
分量的好处。 因此，正如我们所说，罗盘需要

00:21:10.280 --> 00:21:14.519
倾斜补偿，
除非您知道水平

00:21:14.519 --> 00:21:20.400
面相对于您手持
设备的方式，否则您无法计算出您的航向。 倾斜补偿是通过加速度计完成的，

00:21:20.400 --> 00:21:24.840
但它们本身并不能
很好地测量重力。 因此，在

00:21:24.840 --> 00:21:29.940
完成传感器融合之前，您必须使用
加速度计

00:21:29.940 --> 00:21:35.169
和陀螺仪对罗盘进行倾斜补偿，因此您需要进行这种奇怪的引导
。 因此

00:21:35.169 --> 00:21:41.980
，总而言之，陀螺仪再次提供方向，
加速度计提供

00:21:41.980 --> 00:21:48.110
重力校正，罗盘提供
磁北校正。 因此，我将向您展示一个

00:21:48.110 --> 00:22:00.279
小演示。
所以这又是我的剑，这是一起使用所有

00:22:00.279 --> 00:22:14.710
传感器。

00:22:14.710 --> 00:22:20.450
所以假设我刚刚使用了加速度计
和指南针，所以它仍然有效。 它给了

00:22:20.450 --> 00:22:37.299
我正确的答案。 只是很慢，对吧？
有这个延迟。 现在，假设

00:22:37.299 --> 00:22:43.680
我只使用陀螺仪。 所以陀螺仪有
很好的动态响应。 一个完美的陀螺仪，

00:22:43.680 --> 00:22:48.390
我可以永远这样做，它永远不会
漂移，当然，真正的陀螺仪漂移。 所以

00:22:48.390 --> 00:22:52.550
这东西不会永远留在正确的地方。
但短期内看起来还不错。

00:22:52.550 --> 00:23:07.610
你真正想要的是所有这些传感器
在一起，所以现在我有陀螺仪提供

00:23:07.610 --> 00:23:12.460
良好的动态响应，我有加速度计
和罗盘提供长期正确的答案

00:23:12.460 --> 00:23:24.559
。 这就是我的融合数据。
所以现在我们开始定位。 所以加速度

00:23:24.559 --> 00:23:29.179
计测量左右移动，所以你不能从中
获取位置吗？ 好吧，事实证明

00:23:29.179 --> 00:23:35.490
这真的非常非常难，但让我们谈谈
这将如何运作。 所以线性加速度，

00:23:35.490 --> 00:23:40.070
这就是你想要的只是我的左右、
上下和前后运动。 您

00:23:40.070 --> 00:23:43.860
必须获取加速度计数据并且
必须去除重力，这称为重力

00:23:43.860 --> 00:23:50.220
补偿。 所以一旦我移除了重力，
剩下的就是我的线性运动，然后

00:23:50.220 --> 00:23:54.409
你必须对它进行一次积分以获得速度，
再次积分以获得位置，这就是你的

00:23:54.409 --> 00:23:59.960
二重积分。 现在，如果第一个积分——
单个积分会产生漂移，那么双积分

00:23:59.960 --> 00:24:05.769
真的非常讨厌，它们会产生可怕的
漂移。 这是它的图表。 红色的东西

00:24:05.769 --> 00:24:09.940
是一个单一的积分。 你可以看到
我们之前谈到的随机游走，它

00:24:09.940 --> 00:24:16.450
在某个方向上蜿蜒曲折。 绿色信号
是二重积分。 它刚刚起飞。

00:24:16.450 --> 00:24:22.269
现在，这是噪音的整合。 所以你
可以看到这是在模拟加速度计。

00:24:22.269 --> 00:24:26.630
我拿在手里，什么也不做，
一秒钟飘了二十公分

00:24:26.630 --> 00:24:32.780
。 所以我不知道。 是好还是坏？
实际上，我认为这非常好，您

00:24:32.780 --> 00:24:39.460
稍后就会看到。 但是——所以一秒的漂移，
20厘米的误差。 那是来自整合

00:24:39.460 --> 00:24:43.620
噪声。 但这不是问题。 这是
真正的问题。 问题是记得在

00:24:43.620 --> 00:24:47.330
幻灯片开始时我
移除了重力，好吧，我可能没有

00:24:47.330 --> 00:24:52.419
完全正确地做到这一点。 很难
做到完美。 所以假设我弄错了。

00:24:52.419 --> 00:24:56.110
比方说，我以为我拿着这个东西
是 37 度，但我实际上是

00:24:56.110 --> 00:25:02.520
38 度。 所以我把我对重力的估计提高了
一个度数。 好吧，现在，我将

00:25:02.520 --> 00:25:08.690
其双重整合。 我得到一个抛物线。 所以我对
一个常数进行了双重积分，对吗？ 这就是它的

00:25:08.690 --> 00:25:13.159
样子。 因此为了比较，
底部的绿线与

00:25:13.159 --> 00:25:19.820
左侧图中的绿线相同。 现在，它
看起来很平坦，对吧？ 所以新的错误是这条

00:25:19.820 --> 00:25:25.909
蓝色曲线，一秒内有八米半的
错误。 所以我坚持了

00:25:25.909 --> 00:25:31.100
一秒钟。 我把我的方向搞砸了
一个度，我漂移了八

00:25:31.100 --> 00:25:37.909
米半。 所以你可以明白为什么
做任何一种线性运动真的、真的很难。

00:25:37.909 --> 00:25:42.610
因此，第一步是尝试找出如何
在您的应用程序中避免它。 只需使用方向。

00:25:42.610 --> 00:25:48.070
你会很高兴你做到了。 有一些方法
可以改进线性运动估计。 但是

00:25:48.070 --> 00:25:52.049
如果你要做直线运动，任何
方向错误都是非常非常

00:25:52.049 --> 00:25:56.519
重要的。 各种错误，耦合并
包括诸如

00:25:56.519 --> 00:26:02.889
加速度计和陀螺仪之间的交叉访问错误之类的东西，一切都很
重要。 那么，让我们结束这个吧。 我有

00:26:02.889 --> 00:26:09.809
我的方向估计，我添加了线性运动。
所以，你这样做的方法是首先

00:26:09.809 --> 00:26:15.830
使用陀螺仪对加速度计进行重力补偿。
所以为了确保我对向下的方向有最好的

00:26:15.830 --> 00:26:21.529
估计，我需要所有
这些传感器。 然后，一旦我对

00:26:21.529 --> 00:26:26.320
向下的方向有了最好的估计，我就会
减去它。 剩下的就是线性

00:26:26.320 --> 00:26:31.409
加速度，然后我加倍积分并
祈祷。 它仍然通常不能很好地工作。

00:26:31.409 --> 00:26:35.920
所以这里有一些技巧。 好吧，我们拥有的
至少比高通滤波器好。

00:26:35.920 --> 00:26:39.539
这就是现在每个人都在做的事情。 他们想
制作一些你摇晃它的游戏，所以他们对

00:26:39.539 --> 00:26:44.260
加速度计数据进行高通滤波。 无论
剩下什么，他们都会在您摇动信号时祈祷，但

00:26:44.260 --> 00:26:47.549
它确实不起作用。 它
不起作用的原因是因为你假设

00:26:47.549 --> 00:26:52.549
重力变化缓慢但事实并非如此。 重力
以我能做到的速度变化。 所以重力

00:26:52.549 --> 00:26:57.450
变化非常快，因为它是
相对于你的设备的重力，所以高通

00:26:57.450 --> 00:27:01.720
滤波器不能很好地工作。 这样效果
好一些。 如果您对

00:27:01.720 --> 00:27:05.740
设备的运动方式有所了解，您可以
通过使用称为卡尔曼滤波器的东西对您的动力学进行建模来做得更好，

00:27:05.740 --> 00:27:09.549
这可能
是一个完全不同的话题，所以我不打算

00:27:09.549 --> 00:27:14.350
详细介绍它。 但是
假设这些传感器在汽车中。 好吧，

00:27:14.350 --> 00:27:18.809
汽车的移动方式非常受限。 汽车
不能朝任何可能的方向加速。

00:27:18.809 --> 00:27:23.090
例如，他们不会直接上升。
所以你可以使用汽车如何移动的模型来限制你的错误，

00:27:23.090 --> 00:27:27.840
而卡尔曼滤波器是
做到这一点的好方法。 那就是汽车

00:27:27.840 --> 00:27:32.549
导航。 如果你正在做行人导航
并且你想四处走走，通常你会使用

00:27:32.549 --> 00:27:37.840
计步器算法。 所以你不只是双重
整合这个人，你要注意步骤

00:27:37.840 --> 00:27:42.830
并根据步骤做一个算法。 所以
这些是避免双重积分的两个非常常见的技巧

00:27:42.830 --> 00:27:49.080
。 好的，现在，在我们
继续下一节之前，让我们先介绍

00:27:49.080 --> 00:27:54.139
一些术语。 有两个
重要的坐标系。 一个

00:27:54.139 --> 00:27:59.750
是地球坐标系，
包括重力，包括磁北。

00:27:59.750 --> 00:28:04.000
如果您控制的是电视或计算机，则
它包括电视或计算机。

00:28:04.000 --> 00:28:08.230
另一个是
您所持设备的坐标系。 因此，这些通常

00:28:08.230 --> 00:28:12.659
称为地球的世界坐标和
您所持设备的身体坐标

00:28:12.659 --> 00:28:20.660
。 然后，你知道，加速度计
和指南针显然是相对于

00:28:20.660 --> 00:28:24.880
地球进行测量的。 他们测量磁北的重力
。 陀螺仪不同。 它们实际上

00:28:24.880 --> 00:28:28.980
在不同的坐标系中进行测量。
陀螺仪在其自己的坐标系中进行测量。

00:28:28.980 --> 00:28:37.070
所以它测量围绕自身的旋转。
然后现在——很快，

00:28:37.070 --> 00:28:44.049
轴上自由度之间的差异，你
经常看到这个东西——六轴，或者更确切地说。

00:28:44.049 --> 00:28:47.919
那个的真实意义是什么？ 嗯，人们
真正想要的是六个自由度。 这

00:28:47.919 --> 00:28:52.691
意味着我可以左右移动，仅此而已；
前进和后退，这是两个； 上上下下，

00:28:52.691 --> 00:28:57.370
就是三个。 然后你还可以
绕三个轴旋转。 那就是——我们将

00:28:57.370 --> 00:29:01.590
称之为滚动、俯仰和偏航。 虽然，
我们将在第二个中更好地定义它。

00:29:01.590 --> 00:29:06.559
那是六个自由度。 六轴
通常只是指传感器的轴。

00:29:06.559 --> 00:29:11.110
所以，六轴几乎可以代表任何东西，这就是
为什么它在营销中被滥用的原因。

00:29:11.110 --> 00:29:17.110
我有一个六轴传感设备。 我不
知道那是什么意思。 你可以有一个

00:29:17.110 --> 00:29:22.850
单轴加速度计。 您可以
连续放置六个，并称之为六轴传感器。

00:29:22.850 --> 00:29:27.370
所以有些人说六轴时，他们
指的是加速度计和陀螺仪。 有些人

00:29:27.370 --> 00:29:33.600
指的是加速度计和指南针。 不管怎样，
所以六自由度对六轴

00:29:33.600 --> 00:29:43.419
至少知道它们的意思。 好的。 所以现在
我们开始系统集成。 所以，这就是

00:29:43.419 --> 00:29:49.460
我们构建它的部分。 所以我们
拆掉的是耳机插孔。 这可能是

00:29:49.460 --> 00:29:54.821
最有趣的部分。 然后我们拿了一块小板
并将它焊接到 I2C 总线上，然后我们

00:29:54.821 --> 00:30:01.960
开始破解 Android。 这就是我们
所做的。 实际上，我们做的第一件事就是使用标准的 Linux I2C 驱动程序

00:30:01.960 --> 00:30:08.259
围绕我们自己的库构建了我们自己的 JNIWrapper
。

00:30:08.259 --> 00:30:13.309
所以，这并不是真正使用 Android 中的传感器
。 这有点像使用

00:30:13.309 --> 00:30:21.880
Android 附近的传感器或类似的东西。 这
就是我们在第二稿中所做的。 这

00:30:21.880 --> 00:30:25.740
有点棘手，因为现在还
没有真正的好方法可以

00:30:25.740 --> 00:30:32.720
在后处理中对这些传感器进行大量数学运算。
因此，例如，我们可以将其放入内核，

00:30:32.720 --> 00:30:36.850
但我们真的不想将我们的东西
放入内核。 我们可以将它放在用户

00:30:36.850 --> 00:30:41.059
空间，但随后它会被复制。 所以如果你
在传感器管理器中放了太多东西，你就会

00:30:41.059 --> 00:30:45.529
得到传感器管理器的所有这些副本。
所以我们最终做的实际上是破解

00:30:45.529 --> 00:30:49.580
传感器服务，这不是
你应该做的，但它实际上工作得

00:30:49.580 --> 00:30:56.750
很好。 所以我们把我们的司机放在传感器
服务中。 它通过

00:30:56.750 --> 00:31:01.970
标准 I2C 驱动程序与我们的传感器通信，然后将数据
发送到传感器管理器。 我们对它并不是很

00:31:01.970 --> 00:31:07.820
兴奋，但它实际上工作得
很好。 我们正在开发一个新版本，

00:31:07.820 --> 00:31:13.659
效率会更高一些，但这
就是我们现在所处的位置。 所以，也许

00:31:13.659 --> 00:31:16.809
这对你来说并不重要，你只是想
知道如何使用这些数据。 所以这就是

00:31:16.809 --> 00:31:20.779
结果。 所以你有你的传感器管理器，
对吧？ 您想要编写一个

00:31:20.779 --> 00:31:25.669
使用传感器融合的应用程序。 这就是你现在所拥有的
。 您有一些原始数据，还有

00:31:25.669 --> 00:31:31.470
一些指南针和加速度计功能。
所以，我们添加了一大堆其他传感器

00:31:31.470 --> 00:31:36.590
融合的东西。 所以我们有一个四元数
输出，我们用它来做很多事情。

00:31:36.590 --> 00:31:42.750
我们还有旋转矩阵和欧拉角。
然后我们还在其上添加了一堆更高级别的

00:31:42.750 --> 00:31:48.970
算法。 所以我们的手势、
计步器、签名识别，

00:31:48.970 --> 00:31:55.899
我们称之为 Glyph。 这就是我们训练角色的地方。
所以这是我们

00:31:55.899 --> 00:32:00.799
通过传感器管理器公开的整个库。 我们不太
确定这些更高级别的功能应该

00:32:00.799 --> 00:32:06.529
放在哪里，但是我们将它们放在传感器管理器中
并且它对我们有用。 然后，当然，

00:32:06.529 --> 00:32:12.679
所有这些东西都交给了应用程序。
好的。 所以我们到了最后一部分。

00:32:12.679 --> 00:32:20.070
所以这里是你如何使用传感器融合。 那么，
首先，传感器融合会产生什么？

00:32:20.070 --> 00:32:26.059
嗯，我们有我们提到的这个重力矢量
和线性加速度。 因此，考虑这一点的一种方法

00:32:26.059 --> 00:32:30.649
是您拥有加速度计
数据。 这实际上是您分别想要的两件事的总和

00:32:30.649 --> 00:32:36.970
。 所以有时候你需要
重力。 有时你想要你的线性加速度，

00:32:36.970 --> 00:32:41.299
但你 - 你最终得到的是总和。
所以传感器融合基本上可以帮助您将

00:32:41.299 --> 00:32:46.040
它们分开，这样您就可以将重力与
线性加速度分开。 如果将它们重新加

00:32:46.040 --> 00:32:54.090
在一起，您将获得原始加速度计
数据。 然后我们有方向。 好吧，方向

00:32:54.090 --> 00:32:58.490
本身就是一个疯狂的动物园，所以
总是有不同的方式来表达方向。

00:32:58.490 --> 00:33:03.909
欧拉角、旋转矩阵、轴和
角度、四元数，也许您只想

00:33:03.909 --> 00:33:08.279
改变旋转。 因此，我们将
略微介绍所有这些内容，并

00:33:08.279 --> 00:33:15.299
讨论如何在应用程序中使用它们，
并为每个内容编写几行代码。

00:33:15.299 --> 00:33:19.190
当然，
传感器融合带来的另一件事是更好的原始数据。 所以

00:33:19.190 --> 00:33:23.210
所有这些传感器，它们都有问题，但
幸运的是它们有不同的问题。 所以他们

00:33:23.210 --> 00:33:26.920
都有——因为他们都有不同的问题，
他们可以——他们可以互相校准。 一个

00:33:26.920 --> 00:33:35.720
传感器可以使另一个传感器更好。 好的。
所以，很快，重力——好吧，你知道

00:33:35.720 --> 00:33:39.190
那是什么。 每个人都
用它来编写他们的倾斜游戏，对吧？

00:33:39.190 --> 00:33:44.789
除了它不能很好地工作。 因此
移植现有的加速度计代码应该很容易

00:33:44.789 --> 00:33:49.659
。 基本上，你撕掉加速度计的
东西，然后放入重力。 它应该

00:33:49.659 --> 00:33:54.409
工作得更好。 你可以去掉
你一直在使用的那个低通滤波器，因为

00:33:54.409 --> 00:33:59.539
你不再需要它了。 所以，这就是引力。
这可能是最容易了解

00:33:59.539 --> 00:34:03.870
如何使用的方法。 如果您已经知道如何使用
加速度计数据编写倾斜游戏，您可以

00:34:03.870 --> 00:34:10.320
立即编写一个使用
所有传感器的更好的游戏。 线性加速，所以，

00:34:10.320 --> 00:34:16.399
你知道，用于左右摇晃游戏或其他东西
，上下。 同样，您已经

00:34:16.399 --> 00:34:20.080
尝试过使用加速度计数据来做到这一点。 它
没有那么好用。

00:34:20.080 --> 00:34:25.510
只需输入线性加速度
数据，它应该会工作得更好一些。 您现在需要做的就是取出

00:34:25.510 --> 00:34:30.840
您一直在使用的高通滤波器，但它并
没有真正起作用。 我将

00:34:30.840 --> 00:34:38.790
快速演示那个，因为它并不完全
直观。 好的。 所以在左边，我们

00:34:38.790 --> 00:34:43.110
有线性加速度。 在右侧，我们
有原始加速度计数据。 所以你

00:34:43.110 --> 00:34:49.240
再次注意到 Y 加速度计数据在
我前后倾斜时测量重力。 但 Y 线

00:34:49.240 --> 00:34:54.530
加速度数据没有。 所以它保持
为零，因为我没有横向移动。 如果我

00:34:54.530 --> 00:35:00.850
上下移动，他们都会测量，
对吗？ 所以 Y 加速度计和 Y 线性

00:35:00.850 --> 00:35:04.390
加速度都测量这种上下
运动。 但是 Y 加速度计存在

00:35:04.390 --> 00:35:10.220
偏差，这是因为它测量的是
上下运动加上重力。 所以它正在

00:35:10.220 --> 00:35:16.550
测量它们，而 Y 线性加速度
已经通过传感器

00:35:16.550 --> 00:35:24.040
融合过程消除了重力。 是的。 所以如果我把它倒
过来，我就会得到相反方向的偏见。

00:35:24.040 --> 00:35:36.030
好的。 好的，现在我们进入
谈话的最后一部分，即如何表达

00:35:36.030 --> 00:35:42.950
轮换？ 表达旋转实际上非常
非常难。 因此，我们必须

00:35:42.950 --> 00:35:49.880
至少花几分钟时间。 所以，
我们真正要解决的问题是，

00:35:49.880 --> 00:35:54.310
我怎么说绿茶壶发生了什么事，使它
变成了蓝茶壶。 它发生了一些变化

00:35:54.310 --> 00:35:58.830
，它旋转了。 但是你怎么写
下来呢？ 事实证明，有几种方法可以做到

00:35:58.830 --> 00:36:04.291
这一点，但它们都有一些问题。
如果您想

00:36:04.291 --> 00:36:12.670
在应用程序中使用这些东西，最好了解它们是如何工作的。 因此，让我们将
其与线性运动进行比较。 因此，例如，

00:36:12.670 --> 00:36:16.800
假设我有一些想要表达的任意线性运动
。 那是对角绿

00:36:16.800 --> 00:36:22.000
线。 好吧，我可以将其表示为
垂直运动和水平运动的总和。

00:36:22.000 --> 00:36:26.630
所以，太好了，使用矢量效果非常好
。 我也可以走另一条路。 我可以

00:36:26.630 --> 00:36:30.550
先做水平运动，然后做垂直
运动。 它很好用。 那么如果我尝试

00:36:30.550 --> 00:36:35.540
旋转呢？ 好吧，事实证明它并
没有那么好用。 假设我拿起

00:36:35.540 --> 00:36:41.360
我的茶壶，绕着把手旋转，然后绕着
壶嘴旋转。 好吧，这就是

00:36:41.360 --> 00:36:47.150
我结束的地方。 让我们再试一次。 拿起我的茶壶，
绕着壶嘴旋转，然后绕着

00:36:47.150 --> 00:36:53.490
把手旋转。 好吧，我最终去了一个完全
不同的地方。 所以旋转本质上是混乱的。

00:36:53.490 --> 00:36:59.250
它不像线性运动那样有效。
那么我们要做什么呢？ 我们搞砸了吗？

00:36:59.250 --> 00:37:02.720
有几种表达旋转的方法
非常有效。 所以我们将讨论

00:37:02.720 --> 00:37:08.000
这些。 这个真的很作弊，但我
喜欢它。 先不说轮换，只

00:37:08.000 --> 00:37:13.940
说轮换的变化。 那么，从
一点到下一点，我

00:37:13.940 --> 00:37:19.620
绕 Y 轴旋转了多少？ 我绕 X 轴旋转了多少
？ 如果你这样做一段时间，你

00:37:19.620 --> 00:37:23.810
不会得到任何准确的东西，但事实
证明它在用户界面中工作得很好

00:37:23.810 --> 00:37:28.420
。 例如，让我们回到
陀螺仪。 所以我再次向左、向右、向上、

00:37:28.420 --> 00:37:32.770
向下移动。 它工作得很好，对吧？ 好吧，这
其实很容易。 我所做的只是查看

00:37:32.770 --> 00:37:37.650
围绕一个轴的旋转变化，
并将其映射到像素的左右移动

00:37:37.650 --> 00:37:42.250
。 我可以查看
围绕该轴的旋转变化并将其映射到上下移动的像素

00:37:42.250 --> 00:37:52.580
。 所以它看起来是线性的，这就是
为什么它对用户界面很好。 所以总而言之，

00:37:52.580 --> 00:37:57.120
您寻找的角度变化实际上
应该在两个旋转矩阵之间。 这

00:37:57.120 --> 00:38:01.540
不是那么准确。 映射到东西很容易，


00:38:01.540 --> 00:38:07.650
一旦你有了它，你可以用几行代码来完成。 因此，如果您的传感器融合
输出您想要的角度变化，

00:38:07.650 --> 00:38:11.590
那么这里就是您需要的所有代码。 因此，
例如，当我们平移图像时，我们会在平移中使用它

00:38:11.590 --> 00:38:17.420
。 这真的很简单。 只需
在平移变量中累积角度变化，

00:38:17.420 --> 00:38:26.850
然后使用 glTranslate； 三行
代码来制作一个基于运动的平移系统。

00:38:26.850 --> 00:38:32.060
好的，现在我们来看看
以这个人命名的欧拉角。 是的，它发音为 oiler，

00:38:32.060 --> 00:38:36.910
我不确定为什么。 但是，每个人都喜欢欧拉
角，尽管它们实际上并没有

00:38:36.910 --> 00:38:41.520
那么好用。 我们将解释为什么它们不能
很好地工作。 同样，我们要从

00:38:41.520 --> 00:38:47.220
绿茶壶到蓝茶壶。 所以我们可以
将其表示为一系列旋转。 所以

00:38:47.220 --> 00:38:51.150
我们要围绕垂直方向旋转。
我们称之为“偏航”。 我们将

00:38:51.150 --> 00:38:55.370
围绕穿过茶壶侧面的轴旋转它
。 我们将称之为“俯仰”或

00:38:55.370 --> 00:39:00.690
“仰角”，然后我们将通过
喷口旋转，我们将称之为“滚动”。 所以，

00:39:00.690 --> 00:39:05.630
你知道，如果你看看我的手臂，这是偏航。
这也称为航向，就是

00:39:05.630 --> 00:39:10.970
您正在寻找的方向。 这就是俯仰，也叫
仰角。 然后这是滚动，

00:39:10.970 --> 00:39:15.231
绕着我前臂的轴旋转。 现在，我们
有一个问题。 如果我直接指向上方

00:39:15.231 --> 00:39:20.260
并执行此操作会怎样？ 那是偏航还是那滚？
当我改变我的航向时，我

00:39:20.260 --> 00:39:25.710
也绕着一个通过我的前臂的轴旋转
，实际上当你

00:39:25.710 --> 00:39:29.760
用欧拉角笔直指向上方时，一切都会崩溃。
我将演示所有破坏性的东西。

00:39:29.760 --> 00:39:37.710
了解这种情况的发生非常重要。
欧拉角对这些人来说没问题，所以，

00:39:37.710 --> 00:39:44.590
在很多导航系统中，他们都使用
欧拉角。 那么

00:39:44.590 --> 00:39:48.840
不能直指上或直指下是不是问题呢？
好吧，这取决于您的应用程序。

00:39:48.840 --> 00:39:55.120
假设您的应用程序是一架客机、
汽车或潜艇。 事实上，你不能

00:39:55.120 --> 00:39:59.930
直接向上或向下指向并不是
真正的问题。 如果您的俯仰角度达到 90

00:39:59.930 --> 00:40:04.500
度或负 90 度，那么
欧拉角不起作用是您最不担心的事情

00:40:04.500 --> 00:40:12.310
。 因此，让我们在应用程序中使用它
。 只是要小心。 不要让

00:40:12.310 --> 00:40:16.910
你的音调达到 90 度。
您可以使用一些技巧来解决这个问题。 你可以

00:40:16.910 --> 00:40:21.790
在飞行中改变你的定义，所以如果
这是我的前进方向，当我开始

00:40:21.790 --> 00:40:26.410
指向上方时，我可能会遇到麻烦，因为
我的倾斜度将达到 90 度。 快的。

00:40:26.410 --> 00:40:31.140
重新定义一下，这是向前的。 所以现在我的音高
是零。 人们玩所有这些游戏，它们

00:40:31.140 --> 00:40:36.600
真的很乱。 就个人而言，
除非万不得已，否则我尽量避免使用欧拉角。 这里有一些

00:40:36.600 --> 00:40:41.640
代码。 所以一旦你有了一些欧拉角，
你就可以进行俯仰和偏航旋转，

00:40:41.640 --> 00:40:47.100
例如。 这是另一个例子，有时
你很幸运，有人提供了一个可以

00:40:47.100 --> 00:40:52.950
进行俯仰和偏航的 API。 那么让我们看一下
它的演示。 所以，当然，我总是

00:40:52.950 --> 00:41:04.890
带着谷歌地球去大峡谷。 好的。
所以，我偏航了，我们称之为俯仰。

00:41:04.890 --> 00:41:12.700
我可以侧身 这很有趣。 因此，
通过非常少量的移动，我

00:41:12.700 --> 00:41:19.800
可以控制我正在看的方向。 我这样走
，可以往下看。 好的。 那么我会在哪里

00:41:19.800 --> 00:41:26.030
遇到麻烦呢？ 好吧，让我们
直截了当地说一点。 嘿，它工作正常。 那是

00:41:26.030 --> 00:41:30.710
因为我作弊了。 这实际上是滚动。
所以我改变了俯仰和滚动以使其工作。

00:41:30.710 --> 00:41:35.630
那是人们玩的另一个混乱的游戏。 所以
我会告诉你音调。 现在，当我像这样向侧面转弯时

00:41:35.630 --> 00:41:41.270
，最终，我的俯仰角度变为负
90 度，我的欧拉角应该爆炸，就

00:41:41.270 --> 00:41:47.250
这样了。 好的。 所以
知道发生这种情况很重要，对吗？ 如果您打算

00:41:47.250 --> 00:41:53.420
使用欧拉角，但它确实有效，对吧？ 在我
做了我不应该做的事情之前，它一直很有效

00:41:53.420 --> 00:41:58.630
。 所以如果你限制你的应用程序，
欧拉角实际上工作得很好。 好的。

00:41:58.630 --> 00:42:02.340
所以现在我们得到旋转矩阵。 同样，我们
要从绿茶壶转到蓝

00:42:02.340 --> 00:42:07.931
茶壶。 这是一个旋转矩阵。 基本上，
将它乘以绿茶壶上的任意一点。

00:42:07.931 --> 00:42:12.410
它给了你蓝色茶壶上的重点。
所以从这个定义来看，它非常简单。

00:42:12.410 --> 00:42:17.110
是九个数字。 那九个数字是什么
意思？ 我是否应该忽略它们并将

00:42:17.110 --> 00:42:21.500
其用作矩阵并乘以它？
事实上，我喜欢那九个数字。 我喜欢

00:42:21.500 --> 00:42:26.410
用它们来做事。 这是
可视化它们的好方法。 如果你想象 X、Y 和

00:42:26.410 --> 00:42:32.660
Z 轴从茶壶中伸出来，那么这些轴就会
随着茶壶旋转。 你把三个

00:42:32.660 --> 00:42:37.550
轴放在一起，那就是九个数字。 巧合的是，
这些是旋转矩阵中相同的九个数字

00:42:37.550 --> 00:42:42.460
。 因此，例如，如果您有一个旋转
矩阵，并且您想知道茶壶

00:42:42.460 --> 00:42:46.670
壶嘴中的东西会从哪个方向流出
； 你实际上已经有了这些信息。

00:42:46.670 --> 00:42:51.130
它只是一个向量，您可以直接
从旋转矩阵中提取出来。 所以有时你

00:42:51.130 --> 00:42:56.070
可以从旋转矩阵中取出数字
并将它们映射到事物上。 下面介绍如何

00:42:56.070 --> 00:43:01.090
使用旋转矩阵。 您可以使用它
来旋转 OpenGl 中的内容。 所以你去吧。

00:43:01.090 --> 00:43:07.580
只需一行代码即可
在应用程序中使用传感器融合。 你只需将

00:43:07.580 --> 00:43:13.190
它乘以你的旋转矩阵，你就基本上
完成了。 你必须要小心，因为 OpenGl

00:43:13.190 --> 00:43:18.660
实际上是这样定义它们的矩阵的，所以
你可能必须在 1 上添加一些零。

00:43:18.660 --> 00:43:22.410
当然，你也可以——就像我
说的那样，直接从旋转矩阵中提取数字

00:43:22.410 --> 00:43:28.400
并将它们用于其他事情。
看看数字，有时它们很有用。

00:43:28.400 --> 00:43:35.261
好的。 所以，还有几个。 轴和角度。 好吧，
您可以将茶壶

00:43:35.261 --> 00:43:40.260
从绿色到蓝色的旋转表示为绕
该轴旋转该角度。 所以这有点

00:43:40.260 --> 00:43:45.460
有趣。 任何旋转，无论看起来多么奇怪
，您都可以将其记为

00:43:45.460 --> 00:43:50.590
绕一个轴旋转一个角度。 所以你需要
这里的四个数字。 轴的角度和三个

00:43:50.590 --> 00:43:56.260
数字。 我们会
在一秒钟内回到那个。 但首先是四元数，

00:43:56.260 --> 00:44:00.380
所以这些是我的最爱。 每个人都讨厌他们。
人们害怕他们。 他们实际上工作得

00:44:00.380 --> 00:44:04.060
很好。 我认为人们害怕
它们，因为如果你查找它们，你会得到

00:44:04.060 --> 00:44:12.390
类似位于
超球体上的四维向量之类的东西。 那是一个超球体。 实际上，

00:44:12.390 --> 00:44:18.540
你不能真的画一个超球体——我
认为图片说的是二维投影——

00:44:18.540 --> 00:44:24.301
超球体的三维投影
或类似的东西。 无论如何，我真的

00:44:24.301 --> 00:44:29.120
不在乎，因为四元数基本上是一个
角度。 你可以这样使用它。 如果你不

00:44:29.120 --> 00:44:33.930
相信我，那是一个四元数，看看
数字。 有 X、Y 和 Z，这是你的轴，

00:44:33.930 --> 00:44:39.940
还有 theta，那是你的角度。 所以大多数
时候，这就是你使用它的方式。 下面是

00:44:39.940 --> 00:44:46.010
如何在一行代码 glRotatef 中使用四元数
。 就在那里。 这就是那把剑的作用

00:44:46.010 --> 00:44:51.360
。 这也是我们的虚拟
现实小演示的工作原理。 实际上只有一行

00:44:51.360 --> 00:44:56.560
代码可以完成该应用程序中的所有运动感应，
这就是代码行。

00:44:56.560 --> 00:45:00.930
所以你从四元数的第一个分量中取出角度
，然后其他三个

00:45:00.930 --> 00:45:08.260
成为你的轴。 其实很简单。
四元数——人们喜欢它们的原因

00:45:08.260 --> 00:45:12.470
是因为您可以在它们之间进行插值之类的操作
。 不要尝试在

00:45:12.470 --> 00:45:17.490
两个旋转矩阵之间进行插值，因为这通常会造成伤害。
欧拉角也受到伤害。 你可以用

00:45:17.490 --> 00:45:21.720
四元数做到这一点，比如，“我不喜欢我的
绿色和蓝色茶壶。我想找到

00:45:21.720 --> 00:45:26.370
正中间的那个，或者我想推断
并找到下一个。”

00:45:26.370 --> 00:45:33.350
除了四元数之外，这很难做到。
基本上就是这样，我将再展示

00:45:33.350 --> 00:45:41.430
一个演示。 所以这又是我的飞行游戏，
这是我的隧道。 因此，让我们总结一下

00:45:41.430 --> 00:45:46.180
我们所做的一切。 所以这个飞行游戏
使用来自旋转矩阵的向量来

00:45:46.180 --> 00:45:51.221
确定我指向的方向。 它使用
欧拉角的滚动，所以你可以

00:45:51.221 --> 00:45:54.900
在这个游戏中使用欧拉角，对吧？ 因为无论如何我不能
直接指向上方。 我会闯入隧道，

00:45:54.900 --> 00:46:00.101
因此有时您可以限制您的应用程序，
以便欧拉角起作用。 我们在这个游戏中也使用了线性加速

00:46:00.101 --> 00:46:08.441
。 如果我向前冲，它会
加速。 如果我向后拉，它就会慢下来，这样

00:46:08.441 --> 00:46:21.720
你就可以了。 这是你的传感器融合。 好的。
就这样。 谢谢。

